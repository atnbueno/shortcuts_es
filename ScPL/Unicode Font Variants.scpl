@Icon font
@Color green
@ShowInShareSheet [string]

Comment
| This shortcut transforms a text input into a similar string build with Unicode symbols that resemble different typefaces. They can be used to simulate having different fonts where only plain text is available. By default it offers 15 font variants (which are easy to delete or add), and the final result is shown to the user before it can be copied. AFAIK it is the first such tool that does this while keeping diacritics. â€” @atnbueno (2019-02-10)
|
| v1.3.0: Refactorized in ScPL. Added support for UpdateHub. â€” @atnbueno (2020-01-16)
|
| RoutineHubUpdate
|
| Current Version: "1.3.0"
| RoutineHub ID: "4268"
|
| RoutineHubUpdate

//GetTextfromInput
Count Characters
If input="Is Greater Than" number=0
	Comment
	|Text received, so make it the output of the "If" action
	GetVariable s:shortcutinput
Otherwise
	Comment
	| No text received, so ask the user for the text to transform
	|
	| Input example: MaÃ±ana VoilÃ  ChÃ¢teau FraÃ¼lein CafÃ© FaÃ§ade
	AskforInput question="Enter text to transform"
End -> v:"Input Text"

Comment
| These are the predefined variants. Delete any you don't like except the "Plain Text" one. To add your own variant, add a new text value to the dictionary with your replacement for the ten digits, the space, the 26 uppercase letters, and the 26 lowercase letters, in that order.
Dictionary {"Plain Text": "0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", Calligraphy: "0123456789 ð’œâ„¬ð’žð’Ÿâ„°â„±ð’¢â„‹â„ð’¥ð’¦â„’â„³ð’©ð’ªð’«ð’¬â„›ð’®ð’¯ð’°ð’±ð’²ð’³ð’´ð’µð’¶ð’·ð’¸ð’¹â„¯ð’»â„Šð’½ð’¾ð’¿ð“€ð“ð“‚ð“ƒâ„´ð“…ð“†ð“‡ð“ˆð“‰ð“Šð“‹ð“Œð“ð“Žð“", "Calligraphy Bold": "ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ— ð“ð“‘ð“’ð““ð“”ð“•ð“–ð“—ð“˜ð“™ð“šð“›ð“œð“ð“žð“Ÿð“ ð“¡ð“¢ð“£ð“¤ð“¥ð“¦ð“§ð“¨ð“©ð“ªð“«ð“¬ð“­ð“®ð“¯ð“°ð“±ð“²ð“³ð“´ð“µð“¶ð“·ð“¸ð“¹ð“ºð“»ð“¼ð“½ð“¾ð“¿ð”€ð”ð”‚ð”ƒ", "Double-struck": "ðŸ˜ðŸ™ðŸšðŸ›ðŸœðŸðŸžðŸŸðŸ ðŸ¡ ð”¸ð”¹â„‚ð”»ð”¼ð”½ð”¾â„ð•€ð•ð•‚ð•ƒð•„â„•ð•†â„™â„šâ„ð•Šð•‹ð•Œð•ð•Žð•ð•â„¤ð•’ð•“ð•”ð••ð•–ð•—ð•˜ð•™ð•šð•›ð•œð•ð•žð•Ÿð• ð•¡ð•¢ð•£ð•¤ð•¥ð•¦ð•§ð•¨ð•©ð•ªð•«", Fraktur: "0123456789 ð”„ð”…â„­ð”‡ð”ˆð”‰ð”Šâ„Œâ„‘ð”ð”Žð”ð”ð”‘ð”’ð”“ð””â„œð”–ð”—ð”˜ð”™ð”šð”›ð”œâ„¨ð”žð”Ÿð” ð”¡ð”¢ð”£ð”¤ð”¥ð”¦ð”§ð”¨ð”©ð”ªð”«ð”¬ð”­ð”®ð”¯ð”°ð”±ð”²ð”³ð”´ð”µð”¶ð”·", "Fraktur Bold": "ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ— ð•¬ð•­ð•®ð•¯ð•°ð•±ð•²ð•³ð•´ð•µð•¶ð•·ð•¸ð•¹ð•ºð•»ð•¼ð•½ð•¾ð•¿ð–€ð–ð–‚ð–ƒð–„ð–…ð–†ð–‡ð–ˆð–‰ð–Šð–‹ð–Œð–ð–Žð–ð–ð–‘ð–’ð–“ð–”ð–•ð––ð–—ð–˜ð–™ð–šð–›ð–œð–ð–žð–Ÿ", Fullwidth: "ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™â€ƒï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼ºï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½Žï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½š", Monospace: "ðŸ¶ðŸ·ðŸ¸ðŸ¹ðŸºðŸ»ðŸ¼ðŸ½ðŸ¾ðŸ¿ ð™°ð™±ð™²ð™³ð™´ð™µð™¶ð™·ð™¸ð™¹ð™ºð™»ð™¼ð™½ð™¾ð™¿ðš€ðšðš‚ðšƒðš„ðš…ðš†ðš‡ðšˆðš‰ðšŠðš‹ðšŒðšðšŽðšðšðš‘ðš’ðš“ðš”ðš•ðš–ðš—ðš˜ðš™ðššðš›ðšœðšðšžðšŸðš ðš¡ðš¢ðš£", "Sans-serif": "ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ« ð– ð–¡ð–¢ð–£ð–¤ð–¥ð–¦ð–§ð–¨ð–©ð–ªð–«ð–¬ð–­ð–®ð–¯ð–°ð–±ð–²ð–³ð–´ð–µð–¶ð–·ð–¸ð–¹ð–ºð–»ð–¼ð–½ð–¾ð–¿ð—€ð—ð—‚ð—ƒð—„ð—…ð—†ð—‡ð—ˆð—‰ð—Šð—‹ð—Œð—ð—Žð—ð—ð—‘ð—’ð—“", "Sans-serif Bold": "ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµ ð—”ð—•ð—–ð——ð—˜ð—™ð—šð—›ð—œð—ð—žð—Ÿð— ð—¡ð—¢ð—£ð—¤ð—¥ð—¦ð—§ð—¨ð—©ð—ªð—«ð—¬ð—­ð—®ð—¯ð—°ð—±ð—²ð—³ð—´ð—µð—¶ð—·ð—¸ð—¹ð—ºð—»ð—¼ð—½ð—¾ð—¿ð˜€ð˜ð˜‚ð˜ƒð˜„ð˜…ð˜†ð˜‡", "Sans-serif Italic": "ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ« ð˜ˆð˜‰ð˜Šð˜‹ð˜Œð˜ð˜Žð˜ð˜ð˜‘ð˜’ð˜“ð˜”ð˜•ð˜–ð˜—ð˜˜ð˜™ð˜šð˜›ð˜œð˜ð˜žð˜Ÿð˜ ð˜¡ð˜¢ð˜£ð˜¤ð˜¥ð˜¦ð˜§ð˜¨ð˜©ð˜ªð˜«ð˜¬ð˜­ð˜®ð˜¯ð˜°ð˜±ð˜²ð˜³ð˜´ð˜µð˜¶ð˜·ð˜¸ð˜¹ð˜ºð˜»", "Sans-serif Bold Italic": "ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµ ð˜¼ð˜½ð˜¾ð˜¿ð™€ð™ð™‚ð™ƒð™„ð™…ð™†ð™‡ð™ˆð™‰ð™Šð™‹ð™Œð™ð™Žð™ð™ð™‘ð™’ð™“ð™”ð™•ð™–ð™—ð™˜ð™™ð™šð™›ð™œð™ð™žð™Ÿð™ ð™¡ð™¢ð™£ð™¤ð™¥ð™¦ð™§ð™¨ð™©ð™ªð™«ð™¬ð™­ð™®ð™¯", "Sans-serif Small Caps": "ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ« ð– ð–¡ð–¢ð–£ð–¤ð–¥ð–¦ð–§ð–¨ð–©ð–ªð–«ð–¬ð–­ð–®ð–¯ð–°ð–±ð–²ð–³ð–´ð–µð–¶ð–·ð–¸Zá´€Ê™á´„á´…á´‡Ò“É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€sá´›á´œá´ á´¡xÊá´¢", "Serif Bold": "ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ— ð€ðð‚ðƒð„ð…ð†ð‡ðˆð‰ðŠð‹ðŒððŽððð‘ð’ð“ð”ð•ð–ð—ð˜ð™ðšð›ðœððžðŸð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨ð©ðªð«ð¬ð­ð®ð¯ð°ð±ð²ð³", "Serif Italic": "0123456789 ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ð‘€ð‘ð‘‚ð‘ƒð‘„ð‘…ð‘†ð‘‡ð‘ˆð‘‰ð‘Šð‘‹ð‘Œð‘ð‘Žð‘ð‘ð‘‘ð‘’ð‘“ð‘”â„Žð‘–ð‘—ð‘˜ð‘™ð‘šð‘›ð‘œð‘ð‘žð‘Ÿð‘ ð‘¡ð‘¢ð‘£ð‘¤ð‘¥ð‘¦ð‘§", "Serif Bold Italic": "ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ— ð‘¨ð‘©ð‘ªð‘«ð‘¬ð‘­ð‘®ð‘¯ð‘°ð‘±ð‘²ð‘³ð‘´ð‘µð‘¶ð‘·ð‘¸ð‘¹ð‘ºð‘»ð‘¼ð‘½ð‘¾ð‘¿ð’€ð’ð’‚ð’ƒð’„ð’…ð’†ð’‡ð’ˆð’‰ð’Šð’‹ð’Œð’ð’Žð’ð’ð’‘ð’’ð’“ð’”ð’•ð’–ð’—ð’˜ð’™ð’šð’›"} -> v:Charsets

Comment "The following JavaScript snippet applies each charset to the text input, BUT keeping the diacritics (although their placement may not be perfect), and its output is a JSON string, very similar to the dictionary above, but with the user's text replacing the charsets"
Text -> v:JavaScript
| ; let text = `\(v:"Input Text")`.replace(/\\u2060/g, "") // ignores/omits WJ (see about rendering bugs below)
| ; text = text.normalize("NFD") // see https://developer.mozilla.org/Web/JavaScript/Reference/Global_Objects/String/normalize
| ; text = [...text] // see https://ponyfoo.com/articles/es6-strings-and-unicode-in-depth#unicode
| 
| ; // Charset sources: https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols, https://www.compart.com/unicode/
| ; let charsets = \(v:Charsets)
| 
| ; // Search each character in all the charsets and, if found, encode it as its position
| ; let codes = []
| ; for (let c of text) {
| ;     let code = -1; // -1 == not found, leave as is
| ;     for (let i = 0, keys = Object.keys(charsets); (i < keys.length) && (code < 0); i++) {
| ;         code = [...charsets[keys[i]]].indexOf(c)
| ;     }
| ;     codes.push(code)
| ; }
| 
| ; // Transforms the text with each charset (including the "Plain Text" charset in case of transformation undoing)
| ; let output = {}
| ; for (let i = 0, keys = Object.keys(charsets); i < keys.length; i++) {
| ;     let charset = [...charsets[keys[i]]]
| ;     let newText = ""
| ;     for (let j = 0; j < codes.length; j++) {
| ;         let c = charsets["Plain Text"][codes[j]] // The "Plain Text" charset is the reference
| 
| ;         // Weird iOS Unicode rendering bug with "Sans-serif Small Caps" (solved)
| ;         let prefix = ""
| ;         if ((keys[i] == "Sans-serif Small Caps") && ("aeu".indexOf(c) >= 0)) {
| ;             // Adds a WJ prefix to "a", "e" & "u" to avoid them turning to serif
| ;             prefix = "\\u2060"
| ;         }
| ;         // TO DO: Look for solution to avoid "Sans-serif Small Caps" and "Fullwidth" word breaking
| 
| ;         // Weird iOS Unicode rendering bugs with "Calligraphy" (unsolved, only mitigated)
| ;         let suffix = ""
| ;         if ((keys[i] == "Calligraphy") && ("BEFHILMR".indexOf(c) >= 0)) {
| ;             // Adds a WJ suffix to some letters to mitigate weird rendering of "e", "g" & "o"
| ;             suffix = "\\u2060"
| ;         }
| ;         // TO DO: Look for solution to "e", "g" & "o" after space, "BEFHILMR" or themselves
| ;         // TO DO: Look for solution to characters in "BEFHILMR" after non-calligraphic character
| 
| ;         // Replaces each character by their equivalent in each charset
| ;         if (codes[j] < 0) {
| ;             newText += text[j] // non-charset characters
| ;         } else {
| ;             newText += prefix + charset[codes[j]] + suffix
| ;         }
| ;     }
| 
| ;     // Adds transformation to the output array
| ;     output[keys[i]] = newText
| ; }
| 
| ; // Output in JSON format
| ; document.write(JSON.stringify(output))
Comment "The JavaScript code is run and it's output is converted to a Shortcuts dictionary, then the user is shown all their text available variants, and asked to pick one"
URL "data:text/html;charset=utf-8,<script>\(v:JavaScript)</script>"
GetFileofType "com.apple.webarchive"
GetTextfromInput
GetDictionaryfromInput -> v:"Text Variants"

Comment "The list of text variants shown to the user is a list of vCards, instead of the original dictionary, to ensure the order shown is always the same. If any variant coincides with the input text, it will be omitted from the list."
GetVariable v:Charsets
GetDictionaryValue get="All Keys"
RepeatwithEach
	GetVariable v:"Text Variants"
	GetDictionaryValue key=v:"Repeat Item" -> v:"Text Variant"
	If input=Equals value=v:"Input Text"
		Nothing
	Otherwise
		GetVariable v:"Text Variant"
		Comment "As indicated by the RFC 2426 standard, line breaks and semicolons must be escaped"
		ReplaceText findText="\\n" replaceWith="\\\\n" caseSensitive=false regularExpression=true
		ReplaceText findText=";" replaceWith="\\;" caseSensitive=false -> mv:"Replace Text"
		Text "BEGIN:VCARD\nVERSION:3.0\nN;CHARSET=utf-8:\(mv:"Replace Text")\nORG;CHARSET=utf-8:\(v:"Repeat Item")\nEND:VCARD"
	End
End
CombineText separator="New Lines"
SetName name="menu.vcf" -> mv:"Set Name"
Comment "The combined and renamed text is interpreted as Contacts and shown as a menu to the user"
GetVariable mv:"Set Name"{as:contact}
ChoosefromList prompt="Choose your text variant" -> v:"Selected Variant"
Comment "The name of the selected variant is the transformed text chosen by the user. The user is shown the final result and given the option to copy it to the clipboard."
ShowAlert title="Your Text Variant" message="\n\(v:"Selected Variant"{as:contact,get:name})\n\nDo you want to copy it to the iOS Universal Clipboard?" showCancelButton=true
GetVariable v:"Selected Variant"{as:contact,get:name}
CopytoClipboard localOnly=false
